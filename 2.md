# 第二章

## 定点数

### 编码

1. 有符号数原反补移码

   最高位为符号位。正数的原反补码相同。

   - 原码

     若字长为$n+1$，则整数表示范围为$-(2^n-1)\leq x\leq2^n-1$，关于原点对称。

     $0$有正负两种形式。$1,000$和$0,000$。

   - 反码

     负数的反码为其原码各数值位取反。

     表示范围与原码相同。

   - 补码

     负数的补码为其反码末位$+1$。

     若字长为$n+1$，则补码整数的表示范围为$-2^n \leq x \leq 2^n-1$，即多表示了$[-2^n]_补=1,000$。同时，$0$的表示唯一，为$0,000$。

2. 无符号数

   全为数值位，没有符号位，默认为正数。

   若字长为$4$，最小值为$0000$（值为$0$），最大值为$1111$（值为$2^4-1=15$），即表示范围为$0$~$15$。

   无符号数的负数的补码即原码各位取反末位$+1$。

3. 字长转换

   长转短丢弃高位，短转长补码自动在前用符号位的数填满。

### 运算

1.  移位

    - 逻辑移位

      将操作数视为无符号数。左移时，高位移出，低位补$0$；右移时，低位移出，高位补$0$。若高位的$1$左移出，则发生溢出。

    - 算数移位

      将操作数视为有符号数（即补码）。左移时，高位移出，低位补$0$，**若原符号位不同于移位后的符号位，则发生溢出**；右移时，低位移出，高位补符号位，若低位的 1 移出，则影响精度。eg.$1,001$和$0,101$左移时溢出，右移时丢失精度。

2.  补码加减

    $[A+B]_补=[A]_补+[B]_补$(mod $2^{n+1}$)

    $[A-B]_补=[A]_补+[-B]_补$(mod $2^{n+1}$)

    其中，机器字长为$n+1$。

    加法将两个数的补码直接相加，减法将被减数与减数的负数补码相加。

    符号位与数值为一起参与运算。

    高位丢弃，保留$n+1$位，结果亦为补码。

    - 溢出判别

      仅当两符号相同的数相加或两符号相异的数相减才可能发生溢出。以下判别式中

      $V=0$，表示无溢出，$V=1$，表示有溢出。

      - 一位符号位

      1.  设$A$的符号位为$A_S$，$B$的符号位为$B_S$，运算结果的符号位为$S_S$，则溢出逻辑表达式为

          $V=A_SB_S \lnot S_S \lor \lnot A_S \lnot B_S S_S$

      2.  符号位的进位$C_n$与次高位的进位$C_{n-1}$相同则无溢出，否则有溢出。

          $V=C_n \oplus C_{n+1}$

      - 二位符号位

        运算结果的两个符号位$S_{S1}S_{S2}$相同则无溢出，反之溢出。

        $V=S_{S1} \oplus S_{S2}$

    - 无符号数加减

      用一个控制端$Sub$表示加减法，$Sub=0$，表示做加法，$Sub=1$表示做减法。

      做加法时$X+Y=[x]_补+[y]_补$，做减法时$X+ \lnot Y+1=[x]_补+[-y]_补$。

      可以发现，有符号数和无符号数的负数的补码均为各位取反末位$+1$，故用$Sub$完成加减法的电路可同时用于有符号数和无符号数的加减运算。

3.  标志位

    零标志$ZF$：$ZF=1$表示结果为 0。

    溢出标志$OF$：判断有符号数运算是否溢出，对无符号数运算无意义。$OF=1$表示溢出。

    符号标志$SF$：表示结果的符号位，对无符号数运算无意义。

    进/借位标志$CF$：表示无符号数运算的进/借位，判断是否溢出，对有符号数运算无意义。$CF=Sub \oplus C_{out}$。$CF=1$表示溢出。ps.我也不知道为什么减法时无进位代表溢出。
